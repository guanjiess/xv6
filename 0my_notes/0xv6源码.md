==proc.h== : 包含了操作系统内核中用于管理进程核处理系统陷阱的和核心数据结构

defs.h： 这个头文件包含了一系列函数和结构体的声明，这些函数和结构体用于操作系统内核的各个组件，如文件系统、进程管理、内存管理等。这个头文件的目的是为了在代码的不同部分提供函数和结构体的声明，以便在各个模块中使用它们，而无需在每个模块中重新定义这些函数和结构体。 方便不同模块之间的交互、合作。

entry.S： 汇编代码的目的是为每个CPU设置一个栈，然后跳转到C代码的入口点，启动操作系统的初始化过程。然后，它进入一个无限循环，等待其他操作系统组件的执行。 

main.c： 总之，`main` 函数是操作系统内核的入口点，负责执行各种初始化操作，并最终启动进程调度，以便操作系统可以处理用户程序的执行。它还通过 `started` 变量来协调多个CPU的初始化过程。 

initcode.S： 这段代码的主要任务是在用户空间中启动一个进程，该进程执行 `/init` 程序。它设置命令行参数，然后使用 `SYS_exec` 系统调用执行 `/init`，并无限循环等待。一旦 `/init` 进程执行完毕并退出，它也会通过 `SYS_exit` 系统调用退出。这段代码充当了初始化用户进程的入口，通常在操作系统启动时执行。 

init.c： 总体来说，这段代码的作用是初始化操作系统，并启动一个无限循环，用于管理shell进程，以便用户可以通过该shell与操作系统进行交互。 

proc.c(skim)： 是一个用于操作系统内核的一部分，负责管理进程的创建、调度、终止和资源管理等任务。这些功能是操作系统核心的一部分，用于支持多任务处理和用户程序的执行。

exec.c(skim)： 操作系统中的exec系统调用的实现，用于加载并执行一个新的用户程序。

kernel/syscall.h：定义了一些系统调用的常量。在操作系统或者类似的软件中，系统调用是应用程序与操作系统内核之间进行交互的一种方式。每个系统调用都有一个唯一的标识符，这些标识符通常是整数值。这里的代码定义了一些系统调用的标识符

kernel/syscall.c：一个简化的操作系统内核中处理系统调用的部分，用于在操作系统内核中处理用户空间程序的系统调用请求。 

==user/user.h==： `user.h` 提供了用户程序可以调用的系统调用**接口**的声明，`ulib.c` 中实现了一些用户库函数，为用户程序提供了一些常用的工具和功能。 

usys.pl：Perl 脚本，用于自动生成一个包含系统调用桩的汇编代码文件，这些桩用于用户程序与操作系统内核之间的通信。 





==注册系统调用的流程==





==抽时间把这几个文件读了，最好用gdb调试走一遍==

```bash
kalloc.c：用来控制内存的分配

proc.c

sysproc.c

syscall.h

syscall.c

file.c

sysfile.c
```

捋清楚这些系统、文件、调用之间的逻辑关系。









