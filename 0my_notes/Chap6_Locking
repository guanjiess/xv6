一种处理并发性的技术；

属于难点，相关的lab比较困难



xv6中主要用spin-lock；

critical section 临界区

###为什么用锁

目的：为了保证多核CPU执行程序时保证正确性。多核CPU在并行执行应用程序时，同时对某些数据进行读写操作会出现对共享数据的读写冲突（race condition）， 因为 race condition的存在，我们需要使用锁可以序列化代码的执行 。

缺陷：锁的频繁使用会降低性能。

==通常情况下锁有3中应用==

- 锁可以避免丢失更新。如果你回想我们之前在kalloc.c中的例子，丢失更新是指我们丢失了对于某个内存page在kfree函数中的更新。如果没有锁，在出现race condition的时候，内存page不会被加到freelist中。但是加上锁之后，我们就不会丢失这里的更新。

- 锁可以打包多个操作，使它们具有原子性。我们之前介绍了加锁解锁之间的区域是critical section，在critical section的所有操作会都会作为一个原子操作执行。

- 锁可以维护共享数据结构的不变性。共享数据结构如果不被任何进程修改的话是会保持不变的。如果某个进程acquire了锁并且做了一些更新操作，共享数据的不变性暂时会被破坏，但是在release锁之后，数据的不变性又恢复了。你们可以回想一下之前在kfree函数中的freelist数据，所有的free page都在一个单链表上。但是在kfree函数中，这个单链表的head节点会更新。freelist并不太复杂，对于一些更复杂的数据结构可能会更好的帮助你理解锁的作用。

###怎么用锁

==什么时候用锁==

一个简单的标准：如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，就需要对于这个共享的数据结构加锁。 



代码怎么使用锁

```C
structure spinlock lk;
acquire(&lk);

//critical section
//或者叫临界区
//是因为通常会在这里以原子的方式执行共享数据的更新

release(&lk);
```



### 死锁

假设现在我们有两个CPU，一个是CPU1，另一个是CPU2。CPU1执行rename将文件d1/x移到d2/y，CPU2执行rename将文件d2/a移到d1/b。这里CPU1将文件从d1移到d2，CPU2正好相反将文件从d2移到d1。我们假设我们按照参数的顺序来acquire锁，那么CPU1会先获取d1的锁，如果程序是真正的并行运行，CPU2同时也会获取d2的锁。之后CPU1需要获取d2的锁，这里不能成功，因为CPU2现在持有锁，所以CPU1会停在这个位置等待d2的锁释放。而另一个CPU2，接下来会获取d1的锁，它也不能成功，因为CPU1现在持有锁。这也是死锁的一个例子，有时候这种场景也被称为deadly embrace。这里的死锁就没那么容易探测了。 



### 锁与性能

> 1. **竞争和互斥：** 锁通常用于保护共享资源，以防止多个线程或进程同时访问导致数据不一致或竞态条件。然而，过度的锁竞争可能导致性能下降。如果程序中有很多线程在等待同一把锁，那么这种竞争可能成为性能瓶颈。
> 2. **锁的粒度：** 锁的粒度指的是锁保护的临界区的大小。粒度较小的锁可以减少锁竞争，但可能导致过多的锁操作，增加了上下文切换的开销。相反，粒度较大的锁可能减少了锁操作的频率，但增加了锁竞争的可能性。
> 3. **锁的类型：** 不同类型的锁在性能上有不同的影响。例如，自旋锁会在一定时间内忙等待锁的释放，适用于短暂的临界区，但如果临界区较长，可能会导致性能下降。而互斥锁可能涉及进程或线程的切换，引入额外的开销。读写锁可以提高并发性，允许多个线程同时读取，但写入时仍需互斥。
> 4. **避免死锁和饥饿：** 死锁和饥饿可能是由于锁的使用不当引起的性能问题。设计中需要考虑如何避免死锁和确保所有线程都有机会获取锁，以防止饥饿情况的发生。





问题

1. 硬件锁的原子操作？锁操作的原子性？啥叫原子操作？

> 在操作系统中，涉及锁的原子操作是一种无法被中断或分割的基本操作，它在执行过程中不会被其他任务或线程中断。原子操作是一个不可分割的操作序列，要么全部执行成功，要么全部失败，不会出现部分执行的情况。
>
> 在多线程或多进程的环境中，为了确保对共享资源的访问不会导致数据不一致或竞态条件等问题，常常使用锁来保护临界区（Critical Section）。在这种情况下，锁的获取和释放操作通常是原子操作，以确保在多线程环境中的互斥性。
>
> 在具体的编程实现中，不同的操作系统和编程语言提供不同的机制来实现原子操作和锁。一些常见的原子操作包括：
>
> 1. **Test-and-Set（测试并设置）：** 这是一种基本的原子操作，它检查一个内存位置的值并将其设置为新的值。这个操作是原子的，因为它在一个不可分割的步骤内完成。
> 2. **Compare-and-Swap（比较并交换）：** 这个操作会比较一个内存位置的当前值与预期值，如果相等，则将新值写入该位置。这也是一个原子操作，因为整个比较和写入的过程是不可分割的。
> 3. **Fetch-and-Add（获取并增加）：** 这个操作用于原子地读取一个内存位置的值，并将一个常数添加到该值。这样的操作在一条指令内完成，是原子的。
>
> 这些原子操作可以被用来实现各种锁和同步机制，例如自旋锁、互斥锁等。在高级编程语言中，也提供了相应的原语或库函数，用于执行原子操作和管理锁。 

2. 为什么开启中断可以防止死锁？