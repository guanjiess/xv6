## Xv6的常用系统调用

屏蔽了底层硬件的实际，仅仅向外暴露部分应用

==进程和进程间通信==

> 进程是计算机中的一个基本概念，用于描述正在运行的程序，它们提供了隔离、并发执行和资源管理的机制，使得现代计算机系统能够高效地运行多个任务和应用程序 

以进程为单位对CPU的调用进行管理。每个进程的内存包括了指令、数据、栈。

==系统调用==

详见xv6 books，为操作系统提供的函数。

### Process and memory

==process== :进程

`fork`

-  `fork()` 调用会复制当前进程，生成一个新的子进程，但是处理时分配的内存和寄存器不同。因而父进程、子进程之间的操作互不影响
-  fork在父进程返回子进程的pid，在子进程返回0

`wait`

- 对子进程进行回收。父进程可以通过读取wait的参数来决定子进程是否完成。
- 如果一个进程调用fork两次，如果它想要等两个子进程都退出，它需要调用wait两次。每个wait会在一个子进程退出时立即返回。当wait返回时，你实际上没有必要知道哪个子进程退出了，但是wait返回了子进程的进程号，所以在wait返回之后，你就可以知道是哪个子进程退出了。 

### file descriptor and  I/O

- By convention, a process **reads from file descriptor(fd) 0  (standard input), writes output to fd1 (standard input), and writes error message to fd3(standard error)**. 标准描述符，0 1 2
- read(int fd, char *buf, int n )，从fd里读数据
- write(int fd, char *buf, int n )，向fd里写数据
- close，释放一个文件描述符，用以在将来的pipe  \  open 等使用
- open，打开磁盘文件并返回一个文件描述符。
- 每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。 

`exec`

- 执行完程序后自动退出，除非出错，一般不会返回值。



### I/O Redirection

  

### pipe

- 分为写入端`p[1]`和输出端`p[0]`，输入端、输出端在物理地址上其实是两个缓冲区（就是FPGA上写的乒乓缓存）
- 读写是阻塞的，一个管道不能同时进行读写操作，只能进行读和写的一种。所以需要open / close进行操作

### File system

比较难，刚开始留个印象就行

